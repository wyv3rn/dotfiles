#!/usr/bin/env nu

# TODO make these globals configurable
let library = "~/.library" | path expand
let bib_path = $"($library)/bib"
let collection_path = $"($library)/collections"

let viewer = "rlg-sioyek"
let editor = "nvim"
let db_schema = $"($library)/bootstrap.sql"
let db_json = $"($library)/state.json"
let db = $"($library)/sioyek.db"
let browser = "qutebrowser"

def from_bib [item: string] {
    let path = $"($bib_path)/($item).bib"
    let meta = cat $path | sed '/^#/d' | head -n1 | sed 's/[@,]//g' | split row "{"
    if ($meta | length) != 2 {
        error make { msg: $"Item ($item) not found or bib file malformed" }
    }
    if (($meta | get 1) != $item) {
        error make { msg: "Key of the item does not match, please go fix" }
    }
    let body_record = cat $path | sed -n '/=/p' | sed 's/\([^\\]\)"/\1/g;s/=/:/;s/^  //;s/,$//;s/{\(.*\)}/"\1"/;s/\\.//g' | from yaml
    let reftype = $meta | get 0
    let record = {
        ...$body_record
        reftype: $reftype
        key: $item
    }
    $record
}

def my_open [item: string, doi: bool] {
    let pdf_file = $"($library)/pdf/($item).pdf"
    let bib = from_bib $item

    if (($pdf_file | path exists) and $doi != true) {
        nu -c $"($viewer) ($pdf_file) ($db_schema) ($db) ($db_json)"
    } else if ("url" in $bib) {
        nu -c $"($browser) ($bib.url)"
    } else if ("doi" in $bib) {
        nu -c $"($browser) https://doi.org/($bib.doi)"
    }
}

def "main show" [
    item: string
] {
    from_bib $item | print
}

def "main open" [
    item: string
    --doi
] {
    my_open $item $doi
}

def "main fzf" [
    --doi
    --gui
] {
    let list = ^ls $bib_path | sed 's/\.bib$//'
    let item = if $gui {
        $list | gfzf
    } else {
        $list | fzf
    }
    my_open $item $doi
}

def "main edit" [item: string] {
    nu -c $"($editor) ($bib_path)/($item).bib"
}

def my_export [
    collection: string,
] {
    let collection = open $"($collection_path)/($collection).yml"
    let dst = $collection | get dst
    let bib_files = $collection | get src | sort | each {
        |e| $"($library)/bib/($e).bib"
    }

    # TODO shortening is still WIP
    mut short = false
    if "short" in $collection {
        $short = $collection | get short
    }
    mut shorten_sed_cmd = ""
    if $short {
        let short_map = {
            "Proceedings of the ": "",
            "Proceedings on ": "",
        }
        let sed_list = $short_map | transpose from to | each { |e| $"s/($e.from)/($e.to)/" }
        $shorten_sed_cmd = $sed_list | str join ";"
    }

    let prefix = try { $collection | get prefix } catch { "" }
    let prefix_sed_args = $collection | get src | each { |e| $"s/{($e),/{($prefix)($e),/" } | str join ";"

    awk 'FNR==1 && NR!=1 {print ""} {print}' ...$bib_files | sed $prefix_sed_args | sed $shorten_sed_cmd | save -f $dst
}

def "main export" [
    collection: string,
] {
    my_export $collection
}

def "main addto" [
    collection_name: string,
    item: string,
] {
    let path = $"($collection_path)/($collection_name).yml"
    let collection = open $path
    from_bib $item # just to check if it exists
    let src = $collection | get src | append $item | uniq | sort
    $collection | update src $src | save -f $path
    my_export $collection_name
}

def "main rmfrom" [
    collection_name: string,
    item: string,
] {
    let path = $"($collection_path)/($collection_name).yml"
    let collection = open $path
    let src = $collection | get src | where $it != $item | uniq | sort
    $collection | update src $src | save -f $path
    my_export $collection_name
}

def "main yank" [
    item: string
] {
    cat $"($library)/bib/($item).bib" | xclip -selection clipboard
}

def main [] {
    print "No subcommand given"
}

